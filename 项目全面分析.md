## 项目全面分析（最新版）

这是一个 **Shopee（虾皮）商品数据回调任务处理系统**，采用拉取→查询→回调的三阶段流水线架构。

---

### 一、整体架构

```
┌──────────────┐     ┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│   上游API     │────→│  Pull Workers │────→│  TaskQueue   │────→│ Query Workers│
│ (拉取任务)    │     │  (250个)      │     │ (去重队列)    │     │  (50个)      │
└──────────────┘     └──────────────┘     └──────────────┘     └──────────────┘
                                                                       │
                     ┌──────────────┐     ┌──────────────┐            │
                     │  上游回调API  │←────│Callback Workers│←──────────┘
                     │              │     │  (20个)        │
                     └──────────────┘     └──────────────┘
```

**关键文件结构**：

| 文件 | 职责 |
|------|------|
| `src/index.js` | 入口，HTTP/WebSocket 服务启动，进程信号处理 |
| `src/config.js` | 配置管理（环境变量 + 默认值） |
| `src/services/pullService.js` | 从上游批量拉取任务 |
| `src/services/queryService.js` | 调用 Tokege API 查询商品数据 |
| `src/services/callbackService.js` | 回调结果到上游 |
| `src/scheduler/scheduler.js` | **核心调度器**（Worker 编排 / 熔断 / 背压 / 暂停 / 紧急停止） |
| `src/queue/taskQueue.js` | 任务队列（双桶去重） |
| `src/utils/http.js` | 4 个 axios 客户端（pull / upload / tokege / curnum） |
| `src/utils/logger.js` | Winston 日志 + Dashboard 缓冲 |
| `src/websocket.js` | WebSocket 实时控制面板 |
| `src/public/index.html` | Web 控制面板前端 |

---

### 二、拉取与处理回调任务的逻辑

#### 2.1 拉取阶段（`pullService.js`）

- **入口函数**：`pullBatchTask(size)`（26-83 行）
- **接口**：`GET /api/get/tasks?phone=xxx&limit=N`
- **响应格式**：批量格式 `{ success: true, tasks: [{type, data: {...}}, ...] }`
  - 也兼容单条格式 `{ success: true, task: {...} }` 作为降级分支，当前未走到
- **拉取时超时检查**（59-65 行）：任务 `created_at` 超过 3 分钟直接丢弃，计入 `pullExpired`
- 返回标准化任务对象（含 `shop_id`, `item_id`, `good_id`, `country`, `trace_id`, `token` 等字段）
- **拉取速率统计**：秒级桶聚合，计算每分钟拉取次数

#### 2.2 队列阶段（`taskQueue.js`）

- **去重策略**：双桶滚动去重
  - 维护 `_processedCurr` 和 `_processedPrev` 两个 Set
  - 每个桶容量上限 200,000 个 key，满了则滚动
  - key 格式：`${shop_id}:${item_id}:${country}`
  - 内存占用约 56MB（满载 400K key）
- **核心方法**：
  - `enqueue(tasks)` — 入队，同时检查飞行中集合 `dedupeSet` 和已处理桶
  - `dequeue(count)` — 从队头取出，标记为 processing
  - `requeue(tasks)` — 失败任务放回队尾，递增 `retry_count`
  - `requeueSilent(task)` — 放回队尾但不增加重试次数（用于退避）
  - `removeKey(task)` — 标记为已处理，从飞行中集合释放
  - `purgeExpired(timeoutMs)` — 清除过期任务

#### 2.3 查询阶段（`queryService.js` + `scheduler.js`）

- **Query Workers**：50 个并发
- 从 TaskQueue dequeue → 调用 Tokege API 查询 → 结果入 Callback 队列
- 查询前有 **双重过期检查**：
  - `isTaskStale(task)` — 超过 240s（4 分钟）丢弃，**计入超时丢弃率**
  - `isTaskExpired(task)` — 超过 290s（4 分 50 秒）丢弃，计入超时丢弃率
- **正常模式**：批量取 10 个任务并发处理
- **降级模式**：批量取 5 个，严重降级时串行处理 1-3 个

#### 2.4 回调阶段（`callbackService.js`）

- **Callback Workers**：20 个并发
- 批次大小：正常 15，降级模式 8
- **重试机制**：
  - 最大重试次数：`callbackMaxRetry = 5`
  - 重试队列每 5 秒处理一次
  - 重试队列中超过 290s 的任务直接丢弃

---

### 三、超时处理逻辑（5 层超时防线）

| 层级 | 位置 | 阈值 | 计入丢弃率 | 说明 |
|------|------|------|-----------|------|
| **L1** | `pullService.js:59-65` | 180s (3分钟) | 否 | 拉取时丢弃过老的任务 |
| **L2** | `scheduler.js` `isTaskStale()` | 240s (4分钟) | **是** | 查询前过期检查 |
| **L3** | `scheduler.js` `isTaskExpired()` | 290s (4分50秒) | 是 | 查询时过期检查 |
| **L4** | `scheduler.js` `isCallbackTaskExpired()` | 290s (4分50秒) | 是 | 回调时过期检查 |
| **L5** | `callbackService.js:125-135` | 290s | 是 | 重试队列过期清理 |

**HTTP 超时**：

| 客户端 | 超时 | 说明 |
|--------|------|------|
| `pullClient`（拉取上游） | 0（无限制） | 由远端控制 |
| `uploadClient`（上传回调） | 0（无限制） | 由远端控制 |
| `tokegeClient`（Tokege API） | 0（无限制） | 由数据方控制 |
| `curnumClient`（任务量查询） | 10s | 辅助查询，保留超时 |

---

### 四、背压（Backpressure）逻辑

**文件**：`scheduler.js`，函数 `checkBackpressure()`

```
队列水位线:
  ┌─────────────────────────────────────────┐
  │                                         │
  800 ── ▲ HIGH_WATER → 暂停拉取 + 企微告警  │
  │                                         │
  │            正常运行区间                   │
  │                                         │
  100 ── ▼ LOW_WATER  → 自动恢复拉取         │
  │                                         │
  └─────────────────────────────────────────┘
```

- **高水位** `QUEUE_HIGH_WATER = 800`：
  - 设置 `autoPaused = true`
  - 停止所有 Pull Workers
  - 发送企微告警（仅一次，`highWaterAlertSent` 防重复）
- **低水位** `QUEUE_LOW_WATER = 100`：
  - 设置 `autoPaused = false`
  - 自动重启 Pull Workers
- Pull Workers 每次循环检查 `autoPaused` 标志
- Query Workers 每次迭代调用 `checkBackpressure()`

**降级时的流量控制**：
- 查询批次：10 → 5
- 回调批次：15 → 8
- 额外 sleep 延迟降低吞吐

---

### 五、熔断（Circuit Breaker）逻辑

#### 5.1 三个独立健康追踪器

`queryHealth`、`callbackHealth`、`pullHealth`，各自独立跟踪：
- `buckets`：秒级聚合桶（60 秒滑动窗口）
- `windowTotal` / `windowTimeouts`：窗口内总量和超时数
- `consecutiveTimeouts`：连续超时计数器
- `degraded`：降级标志
- `circuitPause`：熔断暂停时长（10s-60s）

#### 5.2 错误分类（`isUpstreamError()`）

识别为上游错误：超时、ECONNREFUSED、ECONNRESET、ENOTFOUND、EPIPE、socket hang up、408、429、5xx

#### 5.3 降级与熔断状态机

```
                    超时率≥70%              连续超时≥200次
  ┌────────┐  ──────────────→  ┌────────┐  ────────────→  ┌────────┐
  │ 正常模式 │                  │ 降级模式 │                │ 熔断暂停 │
  └────────┘  ←──────────────  └────────┘  ←────────────  └────────┘
                    超时率<35%              暂停N秒后恢复
                                           (10s→20s→40s→60s)
```

| 状态 | 触发条件 | 效果 |
|------|---------|------|
| **正常** | 超时率 < 35% | 全速并发批量处理 |
| **降级** | 超时率 ≥ 70% | 批次缩减，串行处理，加入 sleep |
| **熔断** | 连续超时 ≥ 200 次 | 暂停 10-60s（指数退避），恢复后进入降级模式 |

#### 5.4 超时丢弃率保护（三级递进）

丢弃率 = `(queryStaleCount + querySkipCount + queueTimeoutCount + callbackTimeoutDiscards + totalDroppedCount)` / `(成功数 + 丢弃数)`

最低检查门槛：总处理量 ≥ 100 才启用。

| 丢弃率 | 动作 | 可恢复性 |
|--------|------|---------|
| ≥ 10% | 拉取 + 查询降级 | 自动恢复 |
| ≥ 15% | 拉取 + 查询熔断 | 自动恢复 |
| ≥ 20% | **紧急停止** | 需人工介入 |

---

### 六、暂停（Pause）逻辑

系统有 **4 个暂停标志**：

| 标志 | 触发条件 | 影响范围 | 恢复方式 |
|------|---------|---------|---------|
| `pullingPaused` | 手动暂停（Web 面板） | Pull Workers | 手动 `startPulling()` |
| `autoPaused` | 队列背压（>800） | Pull Workers | 队列 <100 自动恢复 |
| `creditExhausted` | Tokege API 积分耗尽 | Pull Workers | 每 30s 探测，积分恢复后自动恢复 |
| `hardStopped` | 丢弃率 ≥ 20% | Pull + Query Workers | 只能手动恢复 |

**Pull Workers 循环条件**：
```javascript
!workersStopped && !pullingPaused && !autoPaused && !creditExhausted && !hardStopped
```

**积分耗尽探测**（`creditProbe()`）：
- `creditExhausted = true` 时每 30 秒试探一次查询
- 成功则恢复 `creditExhausted = false` 并重启 Workers

**Web 面板控制命令**（`websocket.js`）：
- `startPulling` — 恢复拉取（重置所有暂停标志）
- `stopPulling` — 暂停拉取
- `startScheduler` / `stopScheduler` — 启动/停止整个调度器
- `shutdown` — 停止调度器并退出进程

---

### 七、紧急停止（Hard Stop）逻辑

**触发条件**：超时丢弃率 ≥ 20% 且总处理量 ≥ 100

**触发动作**：
1. 设置 `hardStopped = true`
2. 记录错误日志
3. 发送企微紧急告警（含丢弃率、成功数、丢弃数）
4. Pull Workers 和 Query Workers 全部停止
5. **不可自动恢复**，必须通过 Web 面板或 API 调用 `startPulling()` 手动重置

**进程级关闭**（`index.js`）：
- SIGINT / SIGTERM → `scheduler.stop()` → `process.exit(0)`
- 未捕获异常 → 仅在致命错误（socket 耗尽、OOM）时退出

---

### 八、企微通知逻辑

**函数**：`sendWecomAlert(message)`（`scheduler.js`）

**API**：`https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key={WECOM_WEBHOOK_KEY}`

**消息格式**：`msgtype: 'text'`，超时 10s

| 触发场景 | 条件 | 消息示例 | 防重复 |
|---------|------|---------|--------|
| **队列背压告警** | 队列 > 800 | "队列堆积任务: 850（高水位 800）\n系统将在队列降至 100 以下时自动恢复" | `highWaterAlertSent` 标志 |
| **紧急停止告警** | 丢弃率 ≥ 20% | "超时丢弃率: 21.5%（阈值 20%）\n回调成功: 1000\n超时丢弃: 275\n需人工介入恢复" | `hardStopped` 标志（只触发一次） |

未配置 `WECOM_WEBHOOK_KEY` 时跳过发送，打印 warn 日志。

---

### 九、Worker 架构与维护定时器

**三类 Worker**：

| Worker | 数量 | 正常批次 | 降级批次 | 循环终止条件 |
|--------|------|---------|---------|------------|
| Pull Workers | 250 | 并发 5 | 串行 1 | `workersStopped \|\| pullingPaused \|\| autoPaused \|\| creditExhausted \|\| hardStopped` |
| Query Workers | 50 | 批量 10 | 5（严重降级 1-3） | `workersStopped \|\| hardStopped` |
| Callback Workers | 20 | 批量 15 | 8 | `workersStopped` |

**维护定时器**：

| 定时器 | 间隔 | 职责 |
|--------|------|------|
| `cleanupTimer` | 30s | 清理过期队列任务、检查丢弃率 |
| `callbackRetryTimer` | 5s | 处理回调重试队列 |
| `statsTimer` | 10s | 输出统计日志、WebSocket 推送状态 |

---

### 十、关键配置参数

```javascript
// config.js
scheduler: {
  pullInterval: 2000,           // Pull 循环间隔
  pullSize: 250,                // Pull Worker 数量
  batchSize: 200,               // 每次拉取请求的 limit
  pullTaskTimeout: 180000,      // 3分钟 — 拉取时过期丢弃
  queueTaskTimeout: 280000,     // 4分40秒 — 队列清理过期
  queryConcurrency: 50,         // Query Worker 数量
  callbackConcurrency: 20,      // Callback Worker 数量
  callbackMaxRetry: 5,          // 回调最大重试次数
  callbackRetryInterval: 5000,  // 重试队列处理间隔
  callbackSuccessLimit: 10000,  // 成功数上限
  cleanupInterval: 30000,       // 清理循环间隔
}

// HTTP 超时
httpTimeout: 0,                 // upload 客户端 — 无超时
pullTimeout: 0,                 // pull 客户端 — 无超时
callbackTimeout: 0,             // callback — 无超时
// tokegeClient: 0              // tokege — 无超时
// curnumClient: 10000          // curnum — 10s 超时
```

---

### 总结：保护机制全景图

```
                        自动恢复              自动恢复              人工介入
  ┌──────┐  超时率≥70%  ┌──────┐  连续超时≥200  ┌──────┐  丢弃率≥20%  ┌──────────┐
  │ 正常  │───────────→│ 降级  │──────────────→│ 熔断  │────────────→│ 紧急停止  │
  └──────┘  ←─────────  └──────┘  ←────────────  └──────┘             └──────────┘
             超时率<35%            暂停后自动恢复                      ↑ 手动恢复
                                                                      ↓
  队列>800 → 背压暂停（自动恢复）                              企微通知运维人员
  积分耗尽 → 探测恢复（30s/次）
  丢弃率≥10% → 降级 → ≥15% → 熔断 → ≥20% → 紧急停止+企微告警
```
